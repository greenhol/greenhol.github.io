(()=>{"use strict";function t(t){return t.xMax-t.xMin}class i{static copy(t){return new i(t.resolution,t.range)}constructor(t,i){this._resolution=t,this._width=t.width,this._height=t.height,this.setRange(i),console.log(`Grid (${this._width} x ${this._height}) created for resolution: ${t.description}`)}updateRange(t){this.setRange(t),console.log(`Grid (${this._width} x ${this._height}) range set to: ${t.xMin} -> ${t.xMax} and yCenter: ${t.yCenter}`)}getIndex(t,i){return i*this._width+t}pixelToMath(t,i){return[this._xMin+t/this.width*this._xDiff,this._yMax-i/this.height*this._yDiff]}mathToPixel(t,i){return[Math.round((t-this._xMin)*this.width/this._xDiff),Math.round((this._yMax-i)*this.height/this._yDiff)]}get resolution(){return this._resolution}get width(){return this._width}get height(){return this._height}get size(){return this._width*this._height}get ratio(){return this._width/this._height}get range(){return this._range}get xDiff(){return this._xDiff}get blueprint(){return{resolution:{width:this._width,height:this.height,description:`${this._resolution.description} (Copy)`},range:this._range}}toString(){return`width: ${this.width}, height:${this.height} -> size ${this.size}`}setRange(i){this._range=i,this._yDiff=t(i)/this.ratio,this._xMin=i.xMin,this._xMax=i.xMax,this._xDiff=t(i),this._yMin=i.yCenter-this._yDiff/2,this._yMax=i.yCenter+this._yDiff/2}}var e,s,h;function n(t,i,e,s,h){const[n,r]=e.pixelToMath(t,i);let o=0,a=0,g=0;for(;o*o+a*a<h&&g<s;){const t=o*o-a*a+n;a=2*o*a+r,o=t,g++}return g}function r(t,i,e,s,h){const[n,r]=e.pixelToMath(t,i);let o=0,a=0,g=0,u=0,f=0;for(;f<s;){const t=2*o*a;o=o*o-a*a+n,a=t+r;const i=2*(o*u+a*g);g=2*(o*g-a*u)+1,u=i;const e=Math.sqrt(o*o+a*a);if(e>h){const t=Math.sqrt(g*g+u*u);return e*Math.log(e)*2/t}f++}return 0}!function(t){t.START="START"}(e||(e={})),function(t){t.UPDATE="UPDATE",t.RESULT="RESULT"}(s||(s={})),function(t){t[t.ITERATIONS=0]="ITERATIONS",t[t.DISTANCE=1]="DISTANCE"}(h||(h={})),self.onmessage=t=>{const{type:o,data:a}=t.data;if(o===e.START){const t=function(t){const e=i.copy(t.gridBlueprint);let o=0;const a=t.type===h.DISTANCE?r:n;let g=Date.now();const u=new Float64Array(e.size);for(let i=0;i<e.height;i++){for(let s=0;s<e.width;s++)u[e.getIndex(s,i)]=a(s,i,e,t.maxIterations,t.escapeValue);if(o+=e.width,o>5e4){const t=Math.round(i*e.width*100/e.size);self.postMessage({type:s.UPDATE,progress:t}),o=0}}return console.info("#calculateIterations (worker) - calculation done in "+(Date.now()-g)/1e3+"s"),u}(a);self.postMessage({type:s.RESULT,result:t},[t.buffer])}}})();